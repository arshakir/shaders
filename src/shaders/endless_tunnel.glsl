#define T (iTime * 15. + 5.5)

// Tunnel and Sphere size
const float tunnelS = 2.;
const float sphereS = .1;

// Chromatic Abberation
const float redOffset = -0.01;
const float greenOffset = 0.0;
const float blueOffset = 0.01;

// Random and Noise Functions
float random(float x) { return fract(sin(x) * 938475.0); }

vec3 random3D(float x, vec3 a) {
  return vec3(random(x * a.x), random(x * a.y), random(x * a.z) * 5.);
}

float noise(float x) {
  float i = floor(x);
  float f = fract(x);
  return mix(random(i), random(i + 1.0), smoothstep(0., 1., f));
}

vec2 noise2D(float x) {
  vec2 a = vec2(234., 324.);
  return vec2(noise(x * a.x), noise(x * a.y)) - vec2(0.5);
}

// Tunnel path generated by noise func
vec3 path(float z) {
  vec3 a = vec3(475., 34598., .21958);
  return vec3(noise((z + a.x) / 15.) * 5., noise((z + a.y) / 15.) * 7., z);
}

// SDFs for floating spheres
float sphereSDF(vec3 p) {

  vec3 a = vec3(134., 212., 374.);

  float z0 = floor(p.z / 15. + 0.5) * 15.;
  vec3 center = path(z0) + vec3(-0.5) + random3D(z0, a);

  float s = distance(p, center) - sphereS;

  // Create random amount of spheres
  for (float i = 1.; i < 5.; i++) {
    if (i > random(z0 + 100.) * 5.){
      break;
    }
    center = path(z0) + vec3(-0.5) + random3D(i + z0, a) * 2.;
    s = min(s, distance(p, center) - sphereS);
  }

  return s;
}

void mainImage(out vec4 o, in vec2 u) {

  u = (u - iResolution.xy / 2.) / iResolution.y;

  // Chromatic Abberation - offset u for each channel
  float dist = length(u);
  vec2 uChannel[3];
  uChannel[0] = u + vec2(redOffset * dist);
  uChannel[1] = u + vec2(greenOffset * dist);
  uChannel[2] = u + vec2(blueOffset * dist);

  vec3 ro = path(T);
  vec3 rd = path(T + 1.) - ro;

  vec3 c = vec3(0.);
  float d;

  // Repeat for each channel
  for (int i = 0; i < 3; i++) {
    float s; // Total sdf
    d = 0.;

    vec2 u = uChannel[i];

    float sdfTunnel;

    for(int j=0; j < 75; j++) {

      vec3 p = ro + vec3(u + rd.xy, 1.) * d;

      // SDF to the tunnel walls
      sdfTunnel = 0.4 + tunnelS - length(p.xy - (path(p.z).xy));

      // SDF for each of the 4 lines
      float sLine = 99999.;
      vec2 offset[4];
      offset[0] = vec2(1., 1.);
      offset[1] = vec2(1., -1.);
      offset[2] = vec2(-1., -1.);
      offset[3] = vec2(-1., 1.);

      for (int i = 0; i < 4; i++) {
        float s =
            length(p.xy - (path(p.z).xy + normalize(offset[i]) * tunnelS)) -
            0.01;
        sLine = min(sLine, s);
      }

      // Ring z position
      float z0 = floor(p.z / 10. + 0.5) * 10. + 5.;
      float sRing = abs(length(p.xy - path(z0).xy) - tunnelS);
      sRing += abs(abs(z0 - p.z) - 0.1);
      sRing /= 3.;

      float ssphere = sphereSDF(p);

      // Min of all sdfs
      s = min(ssphere, min(sRing, sLine));

      // Check if something was hit
      if (s < 0.01) {
        c[i] = 1.;
      } else {
        c[i] = 0.;
      }

      d += s;
      if (!(d < 50. && s > 0.01 &&
             sdfTunnel > 0.001))
             break;
    }// Stops when ray goes too far, something was
                                 // hit, or hit tunnel wall
  }

  // Make farther objects dimmer and add a base value
  c = c / d * 3. + vec3(0.145098039, 0.145098039, 0.152941176);

  o = vec4(c, 1.);
}
